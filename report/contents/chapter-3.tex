\section{Демонстрация программного продукта и анализ результатов}

\subsection{Обзор прототипа}
В рамках дипломной работы был разработан прототип системы в виде инструмента c интерфейсом командной строки. Рассмотрим его функциональность.

Прототип обеспечивает перенос данных и их удаление из базы данных. Кроме того, данный инструмент позволяет осуществлять перенос и удаление схемы базы данных или выводить схему в формате диаграммы PlantUML \cite{plantuml}.

В прототипе реализованы основные компоненты, указанные на рисунке \ref{Sequence DataTransferComponents}, включая элементы Graph Walker и Data Writer. Процесс обхода данных основан на алгоритме, изображённом на рисунке \ref{algorithm-with-rules}. Для записи данных из одной базы в другую применяется механизм Foreign Data Wrapper.

Кроме того, в прототипе предусмотрены две версии взаимодействия с базой данных и между компонентами Graph Walker и Data Writer: синхронная и асинхронная. В случае синхронного взаимодействия компонент Graph Walker ожидает завершения записи данных компонентом Data Writer, в то время как при асинхронном взаимодействии компоненты функционируют независимо друг от друга.

Также в прототипе поддерживается функциональность следующих конструкции для описания метаданных: \textit{GRAPH SOURCE}, \textit{NO ENTER}, \textit{NO EXIT}, \textit{LIMIT DISTANCE}. Описываются метаданные в формате JSON \cite{json}.

\subsection{Пример использования}

Для иллюстрации использования будет использоваться база данных, изображённая на рисунке \ref{db-example}, которая будет выступать в роли источника. Метаданные для переноса представлены в формате JSON и изображены на рисунке \ref{metadata-example-4-json}.

\begin{figure}
  \begin{lstlisting}
{
  "source_rules": [
    {
      "table": "classes",
      "where": "class_id=1"
    }
  ],
  "traversal_rules": [
    {
      "type": "no_enter",
      "values": [
        {"table": "teachers"}
      ]
    }
  ]
}
  \end{lstlisting}
  \caption{Метаданные в формате JSON}
  \label{metadata-example-4-json}
\end{figure}

Предположим, имеется пустая целевая база данных, в которой отсутствует схема данных. Процесс переноса схемы базы данных, а также самих данных, можно осуществить с помощью двух команд, представленных на рисунке \ref{prototype-execute-example}.

\begin{figure}
  \begin{lstlisting}
./prototype clone-schema --source-db postgresql://user:password@localhost:5432/source --target-db postgresql://user:password@localhost:5433/target

./prototype clone-data --source-db postgresql://user:password@localhost:5432/source --target-db postgresql://user:password@localhost:5433/target --rule-path rules.json
  \end{lstlisting}
  \caption{Примеры запуска программы}
  \label{prototype-execute-example}
\end{figure}

После выполнения команд в целевой базе данных формируется копия схемы исходной базы, и соответствующие данные успешно переносятся.

На рисунке \ref{target-db} отображены данные и их взаимосвязи в целевой базе данных. Можно отметить, что все данные, связанные с классом, имеющим идентификатор \textit{class\_id=1}, были успешно перенесены. При этом данные, содержащиеся в таблице \textit{teachers}, не были включены в целевую базу данных.

\begin{figure}
  \includegraphics[scale=0.5]{./img/jailer-target-db-overview.png}
  \caption{Целевая база данных}
  \label{target-db}
\end{figure}

\subsection{Производительность}

Проведём оценку производительности. В тестах рассматриваются прототипы синхронной и асинхронной версий, а также программа, осуществляющая экспорт всех данных из исходной базы с помощью утилиты \textit{pg\_dump} и их вставку в целевую базу посредством \textit{psql}.

Было проведено суммарно 12 тестов, различающихся объёмом данных, но использующих идентичную схему базы данных, представленную на рисунке \ref{db-example}. Метаданные были сформированы таким образом, чтобы обеспечить полный перенос данных. В каждом тесте измерялось исключительно время, затраченное на полный перенос данных. Тестирование проводилось на компьютере с системой \textit{6.12.12-2-MANJARO}, процессором \textit{AMD Ryzen 7 7700} и \textit{32 GiB} оперативной памяти.

На рисунке \ref{benchmark} и в таблице \ref{tab:benchmark} продемонстрировано время выполнения разных программ для разных тестовых данных. Можно отметить, что время выполнения программы, использующей \textit{pg\_dump}, увеличивается незначительно. Также, начиная с теста, содержащего 770 строк данных, асинхронная версия прототипа демонстрирует более высокую скорость выполнения по сравнению с синхронной версией.

\begin{table}[h!]
    \caption{Таблица сравнения производительности}
    \begin{tabular}{|c|c|c|c|}
        \hline
        \textbf{Количество} & \textbf{Время} & \textbf{Время} & \textbf{Время} \\
        \textbf{строк} & \textbf{синхронной} & \textbf{асинхронной} & \textbf{программы с} \\
         & \textbf{версии (мс)} & \textbf{версии (мс)} & \textbf{pg\_dump (мс)} \\
        \hline
        8 & 332 & 484 & 55 \\
        \hline
        14 & 315 & 450 & 68 \\
        \hline
        26 & 338 & 484 & 58 \\
        \hline
        50 & 383 & 522 & 59 \\
        \hline
        98 & 413 & 514 & 64 \\
        \hline
        194 & 490 & 558 & 62 \\
        \hline
        386 & 577 & 574 & 61 \\
        \hline
        770 & 863 & 780 & 59 \\
        \hline
        1538 & 1410 & 1095 & 60 \\
        \hline
        3074 & 2503 & 1829 & 77 \\
        \hline
        6146 & 4098 & 3063 & 97 \\
        \hline
        12290 & 9858 & 5985 & 96 \\
        \hline
    \end{tabular}
    \label{tab:benchmark}
\end{table}

\begin{figure}
  \includegraphics[scale=0.75]{./img/benchmark.png}
  \caption{График производительности}
  \label{benchmark}
\end{figure}

\subsection{Анализ результатов}

TBD: сделать анализ получившегося прототипа. Написать про жизнеспособность системы: можно ли пользоваться этой системой, либо проще использовать готовые инструменты, в том числе обычные SQL-запросы.
