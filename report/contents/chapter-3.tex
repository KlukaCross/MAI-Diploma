\section{Демонстрация программного продукта и анализ результатов}

\subsection{Обзор прототипа}
В рамках дипломной работы был разработан прототип системы в виде инструмента c интерфейсом командной строки. Рассмотрим его функциональность.

Прототип обеспечивает перенос данных и их удаление из базы данных. Кроме того, данный инструмент позволяет осуществлять перенос и удаление схемы базы данных или выводить схему в формате диаграммы PlantUML \cite{plantuml}.

В прототипе реализованы основные компоненты, указанные на рисунке \ref{Sequence DataTransferComponents}, включая элементы Graph Walker и Data Writer. Процесс обхода данных основан на алгоритме, изображённом на рисунке \ref{algorithm-with-rules}. Для записи данных из одной базы в другую применяется механизм Foreign Data Wrapper.

Кроме того, в прототипе предусмотрены две версии взаимодействия с базой данных и между компонентами Graph Walker и Data Writer: синхронная и асинхронная. В случае синхронного взаимодействия компонент Graph Walker ожидает завершения записи данных компонентом Data Writer, в то время как при асинхронном взаимодействии компоненты функционируют независимо друг от друга.

Также в прототипе поддерживается функциональность следующих конструкции для описания метаданных: \textit{GRAPH SOURCE}, \textit{NO ENTER}, \textit{NO EXIT}, \textit{LIMIT DISTANCE}. Описываются метаданные в формате JSON \cite{json}.

\subsection{Пример использования}

Для иллюстрации использования будет использоваться база данных, изображённая на рисунке \ref{db-example}, которая будет выступать в роли источника. Метаданные для переноса представлены в формате JSON и изображены на рисунке \ref{metadata-example-4-json}.

\begin{figure}
  \begin{lstlisting}
{
  "source_rules": [
    {
      "table": "classes",
      "where": "class_id=1"
    }
  ],
  "traversal_rules": [
    {
      "type": "no_enter",
      "values": [
        {"table": "teachers"}
      ]
    }
  ]
}
  \end{lstlisting}
  \caption{Метаданные в формате JSON}
  \label{metadata-example-4-json}
\end{figure}

Предположим, имеется пустая целевая база данных, в которой отсутствует схема данных. Процесс переноса схемы базы данных, а также самих данных, можно осуществить с помощью двух команд, представленных на рисунке \ref{prototype-execute-example}.

\begin{figure}
  \begin{lstlisting}
./prototype clone-schema --source-db postgresql://user:password@localhost:5432/source --target-db postgresql://user:password@localhost:5433/target

./prototype clone-data --source-db postgresql://user:password@localhost:5432/source --target-db postgresql://user:password@localhost:5433/target --rule-path rules.json
  \end{lstlisting}
  \caption{Примеры запуска программы}
  \label{prototype-execute-example}
\end{figure}

После выполнения команд в целевой базе данных формируется копия схемы исходной базы, и соответствующие данные успешно переносятся.

На рисунке \ref{target-db} отображены данные и их взаимосвязи в целевой базе данных. Можно отметить, что все данные, связанные с классом, имеющим идентификатор \textit{class\_id=1}, были успешно перенесены. При этом данные, содержащиеся в таблице \textit{teachers}, не были включены в целевую базу данных.

\begin{figure}
  \includegraphics[scale=0.5]{./img/jailer-target-db-overview.png}
  \caption{Целевая база данных}
  \label{target-db}
\end{figure}

\subsection{Производительность}

Проведём оценку производительности. В тестах рассматриваются прототипы синхронной и асинхронной версий, а также программа, осуществляющая экспорт всех данных из исходной базы с помощью утилиты \textit{pg\_dump} и их вставку в целевую базу посредством \textit{psql}.

Было проведено суммарно 12 тестов, различающихся объёмом данных, но использующих идентичную схему базы данных, представленную на рисунке \ref{db-example}. Метаданные были сформированы таким образом, чтобы обеспечить полный перенос данных. В каждом тесте измерялось исключительно время, затраченное на полный перенос данных. Тестирование проводилось на компьютере с системой \textit{6.12.12-2-MANJARO}, процессором \textit{AMD Ryzen 7 7700} и \textit{32 GiB} оперативной памяти.

На рисунке \ref{benchmark} и в таблице \ref{tab:benchmark} продемонстрировано время выполнения разных программ для разных тестовых данных. Можно отметить, что время выполнения программы, использующей \textit{pg\_dump}, увеличивается незначительно. Также, начиная с теста, содержащего 770 строк данных, асинхронная версия прототипа демонстрирует более высокую скорость выполнения по сравнению с синхронной версией.

\begin{table}[h!]
    \caption{Таблица сравнения производительности}
    \begin{tabular}{|c|c|c|c|}
        \hline
        \textbf{Количество} & \textbf{Время} & \textbf{Время} & \textbf{Время} \\
        \textbf{строк} & \textbf{синхронной} & \textbf{асинхронной} & \textbf{программы с} \\
         & \textbf{версии (мс)} & \textbf{версии (мс)} & \textbf{pg\_dump (мс)} \\
        \hline
        8 & 332 & 484 & 55 \\
        \hline
        14 & 315 & 450 & 68 \\
        \hline
        26 & 338 & 484 & 58 \\
        \hline
        50 & 383 & 522 & 59 \\
        \hline
        98 & 413 & 514 & 64 \\
        \hline
        194 & 490 & 558 & 62 \\
        \hline
        386 & 577 & 574 & 61 \\
        \hline
        770 & 863 & 780 & 59 \\
        \hline
        1538 & 1410 & 1095 & 60 \\
        \hline
        3074 & 2503 & 1829 & 77 \\
        \hline
        6146 & 4098 & 3063 & 97 \\
        \hline
        12290 & 9858 & 5985 & 96 \\
        \hline
    \end{tabular}
    \label{tab:benchmark}
\end{table}

\begin{figure}
  \includegraphics[scale=0.75]{./img/benchmark.png}
  \caption{График производительности}
  \label{benchmark}
\end{figure}

\subsection{Анализ результатов}

Проведём анализ жизнеспособности системы на основе спроектированной системы, разработанных алгоритма, языка и прототипа, а также результатов производительности.

\subsubsection{Анализ спроектированной системы}

Стоит отметить, что готового решения, удовлетворяющего всем описанным ранее требованиям, в виде единного программного продукта найдено не было. Несмотря на это, задачи переноса взаимосвязанных данных, генерации данных и обфускации данных можно решить с помощью отдельных готовых инструментов.

Например, с помощью инструмента Jailer \cite{jailer} можно получить взаимосвязанные данные. Тем не менее, он обладает только графическим интерфейсом, что усложняет его интеграцию с системами автоматизации. Кроме того, непосредственное подключение к производственной базе конечным пользователем представляет собой значительную угрозу безопасности данных, требующую устранения.

Для анонимизации данных можно использовать инструмент Triki \cite{triki}. Но его нельзя использовать в процессе переноса данных: сначала данные нужно перенести, а только потом анонимизировать. В связи с этим, необходимо обеспечение непрерывности процесса от переноса до анонимизации данных, чтобы пользователи целевой базы не смогли получить доступ к чувствительным данным.

На основании изложенного можно заключить, что сборка рассматриваемой системы из готовых компонентов возможна, но потребует значительных доработок, соизмеримых по трудозатратам с разработкой новой системы.

\subsubsection{Анализ разработанных алгоритма и языка}

Разработанным алгоритму выбора взаимосвязанных данных и языку можно сопоставить sql-запрос с применением CTE \cite{pg-cte}, который будет выбирать взаимосвязанные данные. Но такой запрос будет большим и трудноподдерживаемым.

Особенность разработанных алгоритма и языка состоит в том, что человек, описывающий метаданные, должен хорошо знать структуру базы данных, либо пользоваться инструментами для анализа связей данных, такими как Jailer. В противном случае существует риск неэффективности процесса переноса данных: либо данных будет недостаточно, либо будет их избыток.

\subsubsection{Анализ результатов тестов производительности}

Результаты тестов производительности свидетельствуют о том, что при необходимости переноса всех или большинства данных использование рассматриваемой системы нецелесообразно: в таких случаях предпочтительнее применение \textit{pg\_dump}.

Отметим также, что асинхронная версия прототипа демонстрирует лучшие результаты, что делает использование синхронной версии необязательным.

\subsubsection{Выводы}

Подводя итоги, можно сделать вывод о жизнеспособности системы, однако её применение требует осторожности: необходимо понимание структуры базы данных и объёма данных, требуемых для тестирования.
